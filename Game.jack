class Game
{
  field int MAX_ENEMIES, MAX_ENEMY_SIZE, MIN_ENEMY_SIZE, ENEMY_SPEED, PLAYER_SPEED;
  field Rect player;
  field Array enemies;
  field boolean running;
  // Direction in which the player moves
  // 1 = up, 2 = right, etc.
  // Standing still is not possible in this game
  field int playerDirection, ticks, lastEnemy, lastEnemyY;

  constructor Game new()
  {
    var int i;
    var Rect rect;

    let MAX_ENEMIES     = 20;
    let MAX_ENEMY_SIZE  = 40;
    let MIN_ENEMY_SIZE  = 15;
    let ENEMY_SPEED     = 2;
    let PLAYER_SPEED    = 2;

    let player = Rect.new(0, 0, 20, 20);
    let enemies = Array.new(MAX_ENEMIES);
    let running = true;
    let playerDirection = 2;
    let ticks = 0;
    let lastEnemy = 0;
    let lastEnemyY = 0;

    let i = 0;
    while (i < MAX_ENEMIES)
    {
      let rect =  Rect.new(-100 , -100, 25, 25);
      do rect.isEnemy(true);
      let enemies[i] = rect;
      let i = i + 1;
    }
    return this;
  }

  method void dispose()
  {
    do enemies.dispose();
    do Memory.deAlloc(this);
    return;
  }

  method void clock()
  {
    let ticks = ticks + 1;
    if (ticks > 2000) {
      let ticks = 0;
    }
    return;
  }

  method void handleInputs()
  {
    var char key;

    let key = Keyboard.keyPressed();

    if (key = 81) {
      let running = false;
    }
    if (key = 131) {
      let playerDirection = 1;
    }
    if (key = 132) {
      let playerDirection = 2;
    }
    if (key = 133) {
      let playerDirection = 3;
    }
    if (key = 130) {
      let playerDirection = 4;
    }
    return;
  }

  method void gameLogic()
  {
    var Rect rect;

    if (player.getX() < 0) {
      let playerDirection = 2;
    }
    if (player.getY() < 0) {
      let playerDirection = 3;
    }
    if ((player.getX() + player.getWidth()) > 511) {
      let playerDirection = 4;
    }
    if ((player.getY() + player.getHeight()) > 255) {
      let playerDirection = 1;
    }
    if (playerDirection = 1) {
      do player.moveUp(PLAYER_SPEED);
    }
    if (playerDirection = 2) {
      do player.moveRight(PLAYER_SPEED);
    }
    if (playerDirection = 3) {
      do player.moveDown(PLAYER_SPEED);
    }
    if (playerDirection = 4) {
      do player.moveLeft(PLAYER_SPEED);
    }

    if (MathV2.mod(ticks, Math.divide(2000, Math.multiply(MAX_ENEMIES, 7))) = 0)
    {
      let rect = enemies[lastEnemy];
      let lastEnemyY = MathV2.mod(Math.abs(MathV2.mod(ticks + player.getX(), 512 + player.getY()) + player.getX() - player.getY() - lastEnemyY), 255);
      do rect.setX(512);
      do rect.setY(lastEnemyY);

      do rect.setHeight(MathV2.mod(ticks, MAX_ENEMY_SIZE));
      if (rect.getHeight() < MIN_ENEMY_SIZE) {
        do rect.setHeight(MIN_ENEMY_SIZE);
      }
      do rect.setWidth(rect.getHeight());

      let lastEnemy = lastEnemy + 1;
      if (lastEnemy > (MAX_ENEMIES - 1)) {
        let lastEnemy = 0;
      }
    }

    do moveEnemies();
    return;
  }

  method void moveEnemies()
  {
    var int i;
    var Rect rect;

    let i = 0;

    while (i < MAX_ENEMIES)
    {
      let rect = enemies[i];
      do rect.moveLeft(PLAYER_SPEED);
      let i = i + 1;
    }

    return;
  }

  method void render()
  {
    var int i;
    var Rect rect;

    do player.draw();

    let i = 0;
    while (i < MAX_ENEMIES)
    {
      let rect = enemies[i];
      do rect.draw();
      let i = i + 1;
    }
    return;
  }

  method void run()
  {
    while (running)
    {
      do handleInputs();
      do clock();
      do gameLogic();
      do Screen.clearScreen();
      do render();
      do Sys.wait(20);
    }
    return;
  }
}
